添加这个宏， 因为在头文件中实现， 被多个文件包含会重定义, 所以只在一个地方添加这个宏
#define STB_IMAGE_IMPLEMENTATION
#include "../stb/stb_image.h"


Texture Pixel也叫Texel，你可以想象你打开一张.jpg格式图片，不断放大你会发现它是由无数像素点组成的，这个点就是纹理像素；
注意不要和纹理坐标搞混，纹理坐标是你给模型顶点设置的那个数组，OpenGL以这个顶点的纹理坐标数据去查找纹理图像上的像素，然后进行采样提取纹理像素的颜色


就像普通的纹理过滤一样，切换多级渐远纹理级别时你也可以在两个不同多级渐远纹理级别之间使用NEAREST和LINEAR过滤。
为了指定不同多级渐远纹理级别之间的过滤方式，你可以使用下面四个选项中的一个代替原有的过滤方式


这里用到的都是glTex... 而不是glTexture...


调用glTexImage2D时，当前绑定的纹理对象就会被附加上纹理图像。然而，目前只有基本级别(Base-level)的纹理图像被加载了，如果要使用多级渐远纹理，我
们必须手动设置所有不同的图像（不断递增第二个参数）。或者，直接在生成纹理之后调用glGenerateMipmap。这会为当前绑定的纹理自动生成所有需要的多级渐远纹理


在设置完如何解释顶点属性的原始数据后, 记得开启顶点属性.
glVertexAttribPointer(2, 2, GL_FLOAT, GL_FALSE, 8*sizeof(float), (void*)(6*sizeof(float)));
glEnableVertexAttribArray(2);


当进行放大(Magnify)和缩小(Minify)操作的时候可以设置纹理过滤的选项，比如你可以在纹理被缩小的时候使用邻近过滤，被放大时使用线性过滤。
我们需要使用glTexParameter*函数为放大和缩小指定过滤方式。这段代码看起来会和纹理环绕方式的设置很相似




你可能会奇怪为什么sampler2D变量是个uniform，我们却不用glUniform给它赋值。使用glUniform1i，我们可以给纹理采样器分配一个位置值，
这样的话我们能够在一个片段着色器中设置多个纹理。一个纹理的位置值通常称为一个纹理单元(Texture Unit)。一个纹理的默认纹理单元是0，
它是默认的激活纹理单元，所以教程前面部分我们没有分配一个位置值.

对贴图单元的理解: 本来状态机模型是只有一个概念, 但有不同的状态， 无论处于那个状态，都是操作这一个实例,
比如无论GL_ARRAY_BUFFER绑定到那个VBO, 对顶点的读取就是要读与这个buffer绑定的VBO， 但是某个状态瞬间只能对其中一个操作， 这个状态机的核心
但是贴图如果采用这种概念， 就无法使用多贴图， 因为你可以有多个贴图, 但某个时刻， 你只能操作与GL_TEXTURE_2D绑定的那个贴图,
这正是为什么要提出贴图单元的概念, 我可以有多个不同的贴图单元， 每一个单元是一个状态机， 这没关系.






